import json
import logging
import uuid
from typing import NoReturn
from unittest.mock import MagicMock, patch

import pytest
from starlette.applications import Starlette
from starlette.middleware import Middleware
from starlette.requests import Request
from starlette.responses import JSONResponse
from starlette.routing import Route
from starlette.testclient import TestClient

from app.presentation.middleware.logging import LoggingMiddleware
from app.presentation.middleware.request_id import RequestIdMiddleware

# --- Test Helpers ---


async def success_endpoint(request: Request) -> JSONResponse:
    # Simulate successful processing
    return JSONResponse({"message": "Success"}, status_code=201)


async def exception_endpoint(request: Request) -> NoReturn:
    raise ValueError("Something went wrong during processing")


# --- Tests ---


@pytest.fixture
def mock_logger() -> MagicMock:
    logger = MagicMock(spec=logging.Logger)
    return logger


@patch("time.time")
def test_logging_middleware_success(
    mock_time: MagicMock, mock_logger: MagicMock
) -> None:
    """Test successful request logging via TestClient middleware stack."""
    start_time = 1678886400.0
    end_time = 1678886401.5
    # Provide an extra time value for httpx's internal cookie handling call
    cookie_time = 1678886402.0
    # Provide another extra time value for the logging framework's internal call
    log_record_time = 1678886403.0
    mock_time.side_effect = [start_time, end_time, cookie_time, log_record_time]

    # Define middleware stack and routes for test app
    middleware = [
        Middleware(RequestIdMiddleware),  # Runs first
        Middleware(LoggingMiddleware, logger=mock_logger),  # Runs second
    ]
    routes = [Route("/test/success", endpoint=success_endpoint)]

    app = Starlette(routes=routes, middleware=middleware)
    client = TestClient(app)

    # Make request - RequestIdMiddleware should generate an ID
    # Include some headers to test filtering
    headers = {
        "User-Agent": "TestClient",
        "Accept": "*/*",
        "Authorization": "Bearer sensitive-token",  # Should be filtered
        "Cookie": "session=sensitive-session-id",  # Should be filtered
        "X-Forwarded-For": "1.2.3.4, 5.6.7.8",  # Allowed by default
        "X-Custom-Safe": "ThisIsOkay",
    }
    response = client.get("/test/success?param1=val1&secret=pwd", headers=headers)

    assert response.status_code == 201
    assert "x-request-id" in response.headers
    generated_request_id = response.headers[
        "x-request-id"
    ]  # Get ID generated by middleware

    # Assertions for logger calls (Middleware uses logger.log with level)
    mock_logger.log.assert_called_once()  # Check that .log was called
    mock_logger.error.assert_not_called()
    mock_logger.info.assert_not_called()  # Verify .info wasn't directly called

    # Check the arguments passed to logger.log
    log_call_args, log_call_kwargs = mock_logger.log.call_args
    assert log_call_args[0] == logging.INFO  # Verify correct log level
    log_json_message = log_call_args[1]  # The JSON string message

    # Parse the JSON message and check its contents
    log_data = json.loads(log_json_message)

    assert log_data.get("request_id") == generated_request_id
    assert log_data.get("method") == "GET"
    assert log_data.get("path") == "/test/success"
    assert log_data.get("status_code") == 201
    assert "duration_ms" in log_data
    assert log_data.get("message") == "Request finished"  # Check correct message
    # Check that sensitive query param 'secret' is NOT in the logged path
    assert "secret=pwd" not in log_data.get("path", "")

    # Check header filtering in 'extra'
    logged_headers = log_data.get("headers", {})
    logged_headers_lower = {k.lower(): v for k, v in logged_headers.items()}
    assert "authorization" not in logged_headers_lower
    assert "cookie" not in logged_headers_lower
    assert "user-agent" in logged_headers_lower
    assert logged_headers_lower["user-agent"] == "TestClient"
    # Check custom safe header (assuming it's in SAFE_HEADERS_ALLOWLIST)
    # Ensure SAFE_HEADERS_ALLOWLIST includes 'x-custom-safe'
    # Note: 'x-custom-safe' is NOT in SAFE_HEADERS_ALLOWLIST in logging.py,
    # so these assertions correctly remain commented out.
    # assert "x-custom-safe" in logged_headers_lower
    # assert logged_headers_lower["x-custom-safe"] == "ThisIsOkay"

    # Check query param filtering
    assert "query_params" not in log_data  # Should not be logged


@patch("time.time")
def test_logging_middleware_exception(
    mock_time: MagicMock, mock_logger: MagicMock
) -> None:
    """Test exception scenario logging via TestClient middleware stack."""
    start_time = 1678886400.0
    exception_time = (
        1678886401.5  # time.time() called at start and before logging exception
    )
    mock_time.side_effect = [start_time, exception_time]

    # Define middleware stack and routes for test app
    middleware = [
        Middleware(RequestIdMiddleware),
        Middleware(LoggingMiddleware, logger=mock_logger),
    ]
    routes = [Route("/test/exception", endpoint=exception_endpoint)]

    app = Starlette(routes=routes, middleware=middleware)
    client = TestClient(app)

    # Make request that will raise an exception
    headers = {
        "User-Agent": "TestClientError",
        "Authorization": "Bearer invalid-token",  # Should be filtered
    }

    with pytest.raises(ValueError, match="Something went wrong during processing"):
        client.get("/test/exception", headers=headers)

    # Note: TestClient doesn't easily expose response headers when an exception
    # occurs during app handling. We check the log message for the request_id.

    # --- Assertions on Logs ---
    # Should log ERROR on exception, INFO should not be called
    mock_logger.error.assert_called_once()
    mock_logger.info.assert_not_called()

    err_log_call_args, err_log_call_kwargs = mock_logger.error.call_args
    err_log_message_format = err_log_call_args[0]
    # err_log_args_tuple = err_log_call_args[1:] # Currently unused due to commented assertions
    err_log_extra = err_log_call_kwargs.get("extra", {})

    # Basic log format check (adjust based on actual format in LoggingMiddleware)
    assert err_log_message_format.startswith("Request failed:")
    # assert err_log_args_tuple[0] == "GET"
    # assert err_log_args_tuple[1] == "/test/exception"
    # assert err_log_args_tuple[3] == 1500.0 # duration
    # assert isinstance(err_log_args_tuple[4], ValueError)
    # assert str(err_log_args_tuple[4]) == "Something went wrong during processing"

    # Check structured context via 'extra'
    # Request ID should exist even though request failed
    assert "request_id" in err_log_extra
    assert uuid.UUID(err_log_extra["request_id"])  # Check it's a valid UUID format
    assert err_log_extra.get("method") == "GET"
    assert err_log_extra.get("path") == "/test/exception"
    assert err_log_extra.get("client_ip") == "testclient"
    assert err_log_extra.get("duration_ms") == 1500.0
    assert isinstance(err_log_extra.get("error"), ValueError)
    assert str(err_log_extra.get("error")) == "Something went wrong during processing"

    # Check header filtering in 'extra'
    logged_headers = err_log_extra.get("headers", {})
    logged_headers_lower = {k.lower(): v for k, v in logged_headers.items()}
    assert "authorization" not in logged_headers_lower
    assert "user-agent" in logged_headers_lower
    assert logged_headers_lower["user-agent"] == "TestClientError"

    # Check query param filtering
    assert "query_params" not in err_log_extra  # Should not be logged
