"""
Alert Schemas Module.

This module defines Pydantic models for alert data validation,
serialization, and documentation in the presentation layer, ensuring
strict validation of all input and output data for HIPAA compliance.
"""

from datetime import datetime
from typing import Any
from uuid import UUID

from pydantic import Field, field_validator

from app.core.domain.entities.alert import AlertPriority, AlertStatus, AlertType
from app.core.utils.date_utils import utcnow
from app.domain.entities.biometric_rule import AlertPriority as RuleAlertPriority
from app.domain.entities.biometric_rule import (
    LogicalOperator,
    RuleOperator,
)
from app.presentation.api.schemas.base import BaseModelConfig


class AlertBase(BaseModelConfig):
    """Base schema for alert data with common fields."""

    alert_type: AlertType
    timestamp: datetime
    priority: AlertPriority
    message: str = Field(..., min_length=1, max_length=500)
    data: dict[str, Any] | None = Field(default_factory=dict)

    @field_validator("timestamp")
    @classmethod
    def validate_timestamp(cls, v):
        """Ensure timestamp is not in the future."""
        if v > utcnow():
            raise ValueError("Timestamp cannot be in the future")
        return v


class AlertCreateRequest(AlertBase):
    """Request schema for creating a new alert."""

    patient_id: str | None = None  # For provider-created alerts


class AlertUpdateRequest(BaseModelConfig):
    """Request schema for updating an existing alert."""

    status: AlertStatus | None = None
    priority: AlertPriority | None = None
    message: str | None = Field(None, min_length=1, max_length=500)
    data: dict[str, Any] | None = None
    resolved_at: datetime | None = None
    resolution_notes: str | None = Field(None, min_length=1, max_length=1000)

    @field_validator("resolved_at")
    @classmethod
    def validate_resolved_at(cls, v, info):
        """Ensure resolved_at is only set when status is RESOLVED."""
        # In v2, we need to access the data differently
        values = info.data
        if v and values.get("status") != AlertStatus.RESOLVED:
            raise ValueError("Resolved timestamp can only be set when status is RESOLVED")
        return v


class AlertResponse(AlertBase):
    """Response schema for alert data."""

    id: UUID
    status: AlertStatus
    user_id: str  # The ID of the patient this alert belongs to
    resolved_at: datetime | None = None
    resolution_notes: str | None = None


class AlertsFilterParams(BaseModelConfig):
    """Filter parameters for querying alerts."""

    status: AlertStatus | None = None
    priority: AlertPriority | None = None
    alert_type: AlertType | None = None
    start_date: str | None = None
    end_date: str | None = None


# --- Biometric Alert Rule Schemas ---


class RuleConditionSchema(BaseModelConfig):
    """Schema representing a single condition within a biometric rule."""

    metric_name: str = Field(..., description="The metric being evaluated, e.g., 'heart_rate'")
    operator: RuleOperator = Field(..., description="The comparison operator")
    threshold_value: Any = Field(..., description="The value to compare against")
    time_window_hours: int | None = Field(
        None, description="Optional time window for aggregation (e.g., last 24h)"
    )
    aggregation_method: str | None = Field(
        None, description="Optional aggregation method (e.g., 'avg', 'max')"
    )


class AlertRuleBase(BaseModelConfig):
    """Base schema for biometric alert rules."""

    name: str = Field(..., min_length=1, max_length=100, description="Name of the rule")
    description: str | None = Field(
        None, max_length=500, description="Detailed description of the rule"
    )
    priority: RuleAlertPriority = Field(
        RuleAlertPriority.MEDIUM,
        description="Priority of alerts generated by this rule",
    )
    conditions: list[RuleConditionSchema] = Field(
        ..., min_length=1, description="List of conditions for the rule"
    )
    logical_operator: LogicalOperator = Field(
        LogicalOperator.AND,
        description="Logical operator combining conditions (AND/OR)",
    )
    is_active: bool = Field(True, description="Whether the rule is currently active")


class AlertRuleCreateRequest(AlertRuleBase):
    """Request schema for creating a new biometric alert rule."""

    # patient_id and provider_id might be set by the service/context, not directly in request
    pass


class AlertRuleTemplateCustomization(BaseModelConfig):
    """Schema for customizing alert rule templates."""

    name: str | None = Field(
        None, min_length=1, max_length=100, description="Custom name for the rule"
    )
    description: str | None = Field(
        None, max_length=500, description="Custom description for the rule"
    )
    priority: RuleAlertPriority | None = Field(None, description="Custom priority level")
    threshold_value: Any | None = Field(None, description="Custom threshold value")
    is_active: bool | None = Field(None, description="Custom active status")


class AlertRuleCreateFromTemplateRequest(BaseModelConfig):
    """Request schema for creating a new biometric alert rule from a template."""

    template_id: str = Field(..., description="ID of the template to use")
    patient_id: str = Field(..., description="ID of the patient this rule applies to")
    customization: AlertRuleTemplateCustomization | None = Field(
        None, description="Optional customizations to the template"
    )


class AlertRuleUpdateRequest(BaseModelConfig):
    """Request schema for updating an existing biometric alert rule."""

    name: str | None = Field(None, min_length=1, max_length=100)
    description: str | None = Field(None, max_length=500)
    priority: RuleAlertPriority | None = None
    conditions: list[RuleConditionSchema] | None = Field(None, min_length=1)
    logical_operator: LogicalOperator | None = None
    is_active: bool | None = None


class AlertRuleResponse(AlertRuleBase):
    """Response schema for biometric alert rule data."""

    id: UUID
    patient_id: UUID | None
    provider_id: UUID | None
    created_at: datetime
    last_updated: datetime
    version: int
