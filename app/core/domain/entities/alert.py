"""
Alert Domain Entity Module.

This module defines the core domain entities for alerts in the system,
representing critical information that requires attention from clinicians or patients.
"""

from datetime import datetime
from enum import Enum
from typing import Any


class AlertType(str, Enum):
    """Types of alerts that can be generated by the system."""
    BIOMETRIC_ANOMALY = "biometric_anomaly"
    MEDICATION_REMINDER = "medication_reminder"
    APPOINTMENT_REMINDER = "appointment_reminder"
    SYMPTOM_ESCALATION = "symptom_escalation"
    RISK_THRESHOLD = "risk_threshold"
    TREATMENT_RESPONSE = "treatment_response"
    MEDICATION_INTERACTION = "medication_interaction"
    CLINICAL_ACTION_NEEDED = "clinical_action_needed"


class AlertPriority(str, Enum):
    """Priority levels for alerts."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"


class AlertStatus(str, Enum):
    """Status states for alerts."""
    OPEN = "open"
    ACKNOWLEDGED = "acknowledged"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    DISMISSED = "dismissed"


class Alert:
    """
    Alert domain entity representing critical information requiring attention.
    
    Alerts are a key part of the clinical monitoring system and may represent
    conditions requiring immediate attention from clinicians.
    
    Attributes:
        id: Unique identifier for the alert
        alert_type: Type of alert
        timestamp: When the alert was generated
        status: Current status of the alert
        priority: Priority level of the alert
        message: Human-readable alert message
        data: Additional data related to the alert
        user_id: ID of the user/patient this alert is for
        resolved_at: When the alert was resolved (if applicable)
        resolution_notes: Notes on how the alert was resolved
    """
    
    def __init__(
        self,
        id: str | None,
        alert_type: AlertType,
        timestamp: datetime,
        status: AlertStatus,
        priority: AlertPriority,
        message: str,
        data: dict[str, Any],
        user_id: str,
        resolved_at: datetime | None = None,
        resolution_notes: str | None = None
    ):
        """
        Initialize a new Alert entity.
        
        Args:
            id: Unique identifier (None for new alerts)
            alert_type: Type of alert
            timestamp: When the alert was generated
            status: Current status of the alert
            priority: Priority level of the alert
            message: Human-readable alert message
            data: Additional data related to the alert
            user_id: ID of the user/patient this alert is for
            resolved_at: When the alert was resolved (if applicable)
            resolution_notes: Notes on how the alert was resolved
            
        Raises:
            ValueError: If required fields are missing or invalid
        """
        self.id = id
        self.alert_type = alert_type
        self.timestamp = timestamp
        self.status = status
        self.priority = priority
        self.message = message
        self.data = data
        self.user_id = user_id
        self.resolved_at = resolved_at
        self.resolution_notes = resolution_notes
        
        # Validate entity state
        self._validate()
    
    def _validate(self) -> None:
        """
        Validate the entity state.
        
        Raises:
            ValueError: If entity state is invalid
        """
        if not self.message:
            raise ValueError("Alert message cannot be empty")
            
        if self.status == AlertStatus.RESOLVED and not self.resolved_at:
            raise ValueError("Resolved alerts must have a resolved_at timestamp")
            
        if self.resolved_at and self.status != AlertStatus.RESOLVED:
            raise ValueError("Cannot set resolved_at timestamp for non-resolved alerts")
    
    def resolve(self, notes: str | None = None) -> None:
        """
        Resolve the alert.
        
        Args:
            notes: Optional resolution notes
        """
        self.status = AlertStatus.RESOLVED
        self.resolved_at = datetime.now()
        if notes:
            self.resolution_notes = notes
        
    def acknowledge(self) -> None:
        """Mark the alert as acknowledged."""
        if self.status == AlertStatus.OPEN:
            self.status = AlertStatus.ACKNOWLEDGED
    
    def dismiss(self, notes: str | None = None) -> None:
        """
        Dismiss the alert without resolving the underlying issue.
        
        Args:
            notes: Optional dismissal notes
        """
        self.status = AlertStatus.DISMISSED
        if notes:
            self.resolution_notes = notes
    
    def escalate(self) -> None:
        """Escalate the priority of the alert."""
        # Map priorities for escalation
        escalation_map = {
            AlertPriority.LOW: AlertPriority.MEDIUM,
            AlertPriority.MEDIUM: AlertPriority.HIGH,
            AlertPriority.HIGH: AlertPriority.URGENT,
            AlertPriority.URGENT: AlertPriority.URGENT
        }
        self.priority = escalation_map[self.priority]
        
    def is_active(self) -> bool:
        """
        Check if the alert is active.
        
        Returns:
            True if alert is active, False otherwise
        """
        return self.status in {AlertStatus.OPEN, AlertStatus.ACKNOWLEDGED, AlertStatus.IN_PROGRESS}
    
    def to_dict(self) -> dict[str, Any]:
        """
        Convert entity to dictionary.
        
        Returns:
            Dictionary representation of the entity
        """
        return {
            "id": self.id,
            "alert_type": self.alert_type.value if isinstance(self.alert_type, AlertType) else self.alert_type,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None,
            "status": self.status.value if isinstance(self.status, AlertStatus) else self.status,
            "priority": self.priority.value if isinstance(self.priority, AlertPriority) else self.priority,
            "message": self.message,
            "data": self.data,
            "user_id": self.user_id,
            "resolved_at": self.resolved_at.isoformat() if self.resolved_at else None,
            "resolution_notes": self.resolution_notes
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "Alert":
        """
        Create entity from dictionary.
        
        Args:
            data: Dictionary representation of entity
            
        Returns:
            Alert entity
        """
        # Convert string enum values to enum instances
        alert_type = AlertType(data["alert_type"]) if isinstance(data["alert_type"], str) else data["alert_type"]
        status = AlertStatus(data["status"]) if isinstance(data["status"], str) else data["status"]
        priority = AlertPriority(data["priority"]) if isinstance(data["priority"], str) else data["priority"]
        
        # Parse timestamps
        timestamp = datetime.fromisoformat(data["timestamp"]) if isinstance(data["timestamp"], str) else data["timestamp"]
        resolved_at = None
        if data.get("resolved_at"):
            resolved_at = datetime.fromisoformat(data["resolved_at"]) if isinstance(data["resolved_at"], str) else data["resolved_at"]
        
        return cls(
            id=data.get("id"),
            alert_type=alert_type,
            timestamp=timestamp,
            status=status,
            priority=priority,
            message=data["message"],
            data=data.get("data", {}),
            user_id=data["user_id"],
            resolved_at=resolved_at,
            resolution_notes=data.get("resolution_notes")
        )
